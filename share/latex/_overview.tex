\hypertarget{_overview_Hamiltonian}{}\section{Hamiltonian}\label{_overview_Hamiltonian}
Non\-Ad\-M\-D is meant to treat systems that can be written with the following mixed quantum-\/classical Hamiltonian\-:\par
 $H=hs+hb+hc$\par
 where {\itshape hs} is the quantum subsystem Hamiltonian, {\itshape hb} is the environment(bath) classical subsystem Hamiltonian , and {\itshape hc} is a coupling term that links the two subsystems. Propagation methods are used to evolve the system in time and spectrometer functions are used to observe spectral properties of the system. The spirit of the entire project is to divorce the propagation methods and the spectrometer functions from the attributes of the the system it operates on. In other words, the propagator and the spectrometer know not how to compute the classical force field nor how the quantum states are parametrized by the nuclear configuration, rather they rely on the system itself to provide those details by means of a standard interface. This is accomplished by giving the Hamiltonian components {\itshape hs}, {\itshape hb}, and {\itshape hc} a standard set of attributes that all subsystems of interest will have in common. Thus, {\itshape hs}, {\itshape hb}, and {\itshape hc} can be thought of as prototype or primitive subsystems upon which all derived subsystems can be built.\hypertarget{_overview_Derived_Subsystems}{}\section{Derived Subsystems}\label{_overview_Derived_Subsystems}
This distribution provides a few standard subsystem and coupling types you may find useful, however the spirit of this project is to provide a clean method for you to develop your own particular Hamiltonian. This process is accomplished by the use of derived subsystems. Derived subsystems inherit all attributes of the primitive subsystem they derive from. At the lowest level there is a primitive subsystem {\itshape hs}, {\itshape hb}, or {\itshape hc} for the Hamiltonian quantum subsystem, classical subsystem , and coupling term respectively. The primitive thus defines the greatest common denominator (G\-C\-D) among all derived quantum, classical, or coupling subsystems. The propagator, spectrometer, and even the 3 components of the Hamiltonian must all communicate with one another on this G\-C\-D footing. In this way users are free to develop unique subsystems, entire Hamiltonians, or even propagation methods and spectrometer functions that can be confidently used by the entire community.

Composing derived quantum, classical, and coupling subsystems is described in more detail in the Developer's Manual share/\-Dev\-Manual.\-txt.\hypertarget{_overview_Generic_Subsystems}{}\section{Generic Subsystems}\label{_overview_Generic_Subsystems}
At the user interface level (system driver) the details of the derived subsystem is hidden. Instead the user encounters generic quantum, calssical and coupling subsystem types {\itshape qs}, {\itshape cs}, and {\itshape cp} respectively. The user can treat these like any of the available derived types. All one has to do is tell the generic subsystem to behave like one (and only one) of the available derived types. To compute dynamical information the user would simply pass these generic subsystems into the propagator. The propagator doesn't care what derived subsystem was passed to it nor does it have a list of possible subsystems to treat for that matter. In fact, the subsystem you pass to the propagator may be your own never-\/before-\/seen creation. That is the beauty of this application!\hypertarget{_overview_System_Driver}{}\section{System Driver}\label{_overview_System_Driver}
O\-K, so full disclosure -\/ you will have to code in F\-O\-R\-T\-R\-A\-N. {\itshape D\-O\-N'T} {\itshape P\-A\-N\-I\-C!} You only have to learn 7 commands... well, 7ish but more on that later. First of all I bet you're asking yourself, 'So where do I write down these \char`\"{}7\char`\"{} commands?' Well I'll just ignore those \char`\"{}ironic\char`\"{} quotes you just tried to slide in there and jump right into the system driver.

After unpacking and installing the code, (look in Install page under 'Getting Started' for that) go to your build directory and look for a file titled 'system\-\_\-driver.\-f90' in the src/ directory. Open this file and look for a line that reads 'body of experiment'. Here you will use the previously mentioned 7 commands to construct a Hamiltonian, make pre(post) production observations, and run dynamics. Generally, building the Hamiltonian and making observations is done in serial while dynamics are run in paralell (again look at the Install page for serial versus parralell installation) which is why you should see example commands like 'N\-E\-W', 'S\-A\-V\-E', and 'O\-B\-S\-E\-R\-V\-E' inside of if(myid.\-E\-Q.\-master) blocks and an example 'R\-U\-N' command outside of the if statement block. What is happening here is that every processor running the code is assigned a label stored in 'myid' and 'master' is a special label defining the processor used for building the Hamiltonian and such. When you run the code in serial there is only one processor and it is labeled the master processor by default. These example commands should help you figure most of the basics of running a simple calculation. For a more detailed disscusion on how to use the code read ahead to the Interface page under the 'Getting Started' tab. Good Luck! 